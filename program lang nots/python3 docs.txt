THIS IS FILE ON PYTHON 3 TRICKS AND FUNCTIONS SHORTCUTS:
=========================================================

*)LISTCOMPREHENSION: we can use this to generate list without writing to many code , just in one line we can get the list

*)SWAPCASE() : This function swaps the case of the string that is being given , it dont take arguments 

*)len() :  to find the length of the string or list or any thing
*)count(): this count the frequency of the value in the list.
*)import random------- this class is used to generate random values in python

*) TO FIND THE SECOND LARGEST DIGIT:
		z= max(lis)
		if(max(lis)==z):
			lis.remove(z)
		z=max(lis) # this is the second largest number after removing the largest and repeting number that was max.

*)join() : this is to join the values with the value given in the string for example;
		s=s.split()
		"-".join(s)
		============ this gives thee value with "-" in between the words.

*) if we want to change the string then we can use slice function or [] things eg:
		def mutate_string(string, position, character):
   			 string = string[:position]+character+string[position+1:]
   			 return string

*)eval(): this is use to evluate an expression and return the value, like we can do validations and solve
	 maths expression, it automatically understands the data type and return that type

*)any(): it returns TRUE if any item in iterable is true else return false, it also returns false if its empty
*) sorted() and sort(): the sort function modifies the original list or tuple... sorted() where as returns a sorted list or tuple and does not modifies the original list.
=======================================================================================

					SETS
				===================

*)SETS ARE NOT MUTABLE That is orignal set cant be changed just like strings.
*)sets are a collection which are unordered and unidexed. therefore we dont know in which order the set will be printed.
*)sets with numbers have unique values and are printed in sorted order 
*)to make a set with values as string for numbers we can use map function as and store as a list
	****lis1=list(map(int,lis))****
*)Here are some of the functions that are related to sets in python 3:
.)set is created as s= {1,2,4,5} // this is a set of numbers just like in maths
.)to loop we use ------------( for x in s):
.)add()... update()--------- to add one item to set we use add() and to add more than one we use update()
		thisset.update(["oranges","mangoes"])
		print(thisset)
.)update(): this will join the new set to last of the set and updates the set
.)len(): to get the number of elements in the set
.)remove() , discard() : to remove an element from the set but remove returns key error if not found the element whereas discard() does not.
.)pop() : removes the last element from the set but since we dont know how the set is ordered we cant say that which element will be poped
.)clear() : this empties the set and returns empty set
.)del: this keyword will delete the set completly eg: del thisset

===============================Here are math functions related to sets in python===============================
			     ====================================================
.)JOIN TWO SETS::: we can do this by many ways they are as ::: using union() or using update()
.)union(): this joins two set and returns a new set
.)set(): we can use this to change the list to set, this is called set constructor
.)symmetric_difference(): returns the A^B that is except the common elements rest all is returned. This is symmetric difference of two sets.
.)diffrence(): this returns the values that are in set A but not in set B (A-B).
.)intersection(): returns a set that is intersection of two sets
.)isdisjoint(): returns if two sets have intersection or not
.)issubset(): returns if another set contains this set or not
.)issuperset(): returns if this set conatains another set or not
===============================Mutation of the set (changes in the orignal set)===============================
			=============================================================
Operations like update() or |, intersection_update() or &, difference_update() or -=, symmetric_difference_update() or ^=, are few functions
.)update(): update the elements of the set by adding the elements of another set or iterable to the set.
.)intersection_update(): update the set by keeping only the elements found in it and the iterable or another set
.)difference_update(): update the set by removing elements found in the iterable or another set
.)symmetric_difference_set(): update the set by only keeping the elements found in either set by not in the both

===============================OPERATORS===============================
			      ===========
1) in: This is used to check if a value exists in a sequence or not. Evaluates to True if found else False.
2) not in: This Evaluated to True if not found a variable in the specific sequence and false otherwise.
			Identity Opertators
1)is: Evaluates True if the variable on either side of the operator point to the same object and false otherwise eg: if(type(x) is int):

2)is not: Evaluate to false if the variable on the either side of the operator point is same othewise true.

===============================MATHS OPERATIONS===============================
			==============================
1)divmod(a,b): this returs the tuple that has quotent and the remainder of a/b like(a//b,a%b), // this act as integer division in python 3 and python 2
2)pow(a,b) or a**b: to return the power of the b times a.
3)==================================to be continued=================================


===================================ITERTOOLS===================================
				===============
we have to import itertools for using it.

1)itertools.product(): .)This tools computes the cartesian product of input iterables.
		       .)This is equivalent to nested for-loops.
			.)For example, product(A, B) returns the same as ((x,y) for x in A for y in B). 
			.) eg: >>> print list(product([1,2,3],repeat = 2))
					[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
			.) eg: >>> print list(product([1,2,3],[3,4]))
					[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]
			>>>
				>>> A = [[1,2,3],[3,4,5]]
				>>> print list(product(*A))
					[(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)]
			>>>
				>>> B = [[1,2,3],[3,4,5],[7,8]]
				>>> print list(product(*B))
					[(1, 3, 7), (1, 3, 8), (1, 4, 7), (1, 4, 8), (1, 5, 7), (1, 5, 8), (2, 3, 7), (2, 3, 8), (2, 4, 7), (2, 4, 8), (2, 5, 7), (2, 5, 8), (3, 3, 7), (3, 3, 8), (3, 4, 7), (3, 4, 8), (3, 5, 7), (3, 5, 8)]
			the difference between the two exressions is:
				print(list(itertools.product(*A)) = print(itertools.product(*A))
					A=[[1,2]]==== (1,),(2,)


2)itertools.permutations():	SYNTAX: itertools.permutations(iterable,[,r])--------- here iterable is whose permutation is to be found and r is the length for all the permutations.
				.)If the r value is not given then by default the length of r is taken as the length of the iterable.
				.)examples:  
				>>> from itertools import permutations
				>>> print permutations(['1','2','3'])
					<itertools.permutations object at 0x02A45210>
			>>> 
				>>> print list(permutations(['1','2','3']))
					[('1', '2', '3'), ('1', '3', '2'), ('2', '1', '3'), ('2', '3', '1'), ('3', '1', '2'), ('3', '2', '1')]
			>>> 
				>>> print list(permutations(['1','2','3'],2))
					[('1', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('3', '1'), ('3', '2')]
			>>>
				>>> print list(permutations('abc',3))
					[('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]

3)itertools.combinations(): same as permutation just the difference is that it is used to generate the combinations.
				here the elements are seen as unique on the basis of their value and not the position.
				example: (s="ABC", this will be as : (A,B),(A,C),(B,C)

4)itertools.cobination_with_replacement(): here elements are considered as unique on their place value and the actual value.
				eg: s="ABC"--- : (A,A),(A,B),(A,C),(B,B),(B,C),(C,C)
	print(*[''.join(i) for i in permutation(sorted(s),int(n))],sep='\n')----------- printing each element in new line

5)itertools.groupby(iterable,[,key]):	1)groups consequtive element of same occurence
					2)we have to sort the series as if we dont then we will get multiple key for same type of elements
					3)this is an iterator that means that this points to a value and not return any value but the address
					4)We have to sort the sequence as if we did this then the first value will be considered as the key value.
					5)but if we dont sort the series then we will get multiple key for the same value.

=========================================================================================================================================================================
					COLLECTIONS CLASS
				==================================
1)collections.Counter(): this is used to count the frequency of the elements in a string or list or tuple.
			this returns a dict. with decreasing order of frequency
			this has three functions that is... items(), values(), keys().
			items(): returns the tuple with (key and value) where key is the element and value is its freq.
			values(): returns the frequency list of the elements 
			keys(): returns what are the elements in the set	
			program:
				from collections import Counter
				n =[1,2,3,5,6,1,2,3,4,5,7,6]
				print(n)
				print(Counter(n).items())
				print(Counter(n).values())
				print(Counter(n).keys())

2)collections.









